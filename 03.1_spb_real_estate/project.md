Для работы с `plotly` используем другие знакомые вам данные — архив объявлений о продаже квартир в Санкт-Петербурге и Ленинградской области из курса «Исследовательский анализ данных». 

Вас просят построить несколько интерактивных графиков, которые покажут:

- как меняется общая площадь квартир в зависимости от расположения;
- как меняется медианная стоимость квартир по годам и месяцам за исключением 2014 года;
- как меняется количество объявлений в зависимости от числа комнат;
- какие пять населённых пунктов, кроме Санкт-Петербурга, лидируют по количеству объявлений;
- как цена за квадратный метр зависит от общей площади квартиры в Санкт-Петербурге и вне его.

Библиотека `plotly` — самостоятельный инструмент. Поэтому импортировать matplotlib или seaborn не потребуется. Понадобится библиотека `pandas`, а также `plotly` в двух вариантах: `plotly.express` и `graph_objects`.

```
# импортируем библиотеки и загружаем данные
import pandas as pd
import plotly.express as px
from plotly import graph_objects as go
df = pd.read_csv('/datasets/real_estate_data.csv', sep='\t')
```
Подготовим данные: удалим пропуски, добавим столбцы с категориями, значениями месяца и года.
```
# удаляем пропуски 
df['locality_name'] = df['locality_name'].fillna('неизвестно')
# создаём категории для населённых пунктов
df['locality_name_category'] = 'Другое'
df.loc[df['locality_name'] == 'Санкт-Петербург', 'locality_name_category'] = 'Санкт-Петербург'
# переведём first_day_exposition в формат дата-время
df['first_day_exposition'] = pd.to_datetime(df['first_day_exposition'], format=('%Y-%m-%dT%H:%M:%S'))
# добавляем столбец с месяцем
df['month'] = df['first_day_exposition'].dt.month
# добавляем столбец с годом
df['year'] = df['first_day_exposition'].dt.year
```
### 1  Площадь квартир в зависимости от расположения

Отобразим, как различается общая площадь квартир в разных категориях населённых пунктов. Построим две гистограммы распределения: одну для Санкт-Петербурга, вторую для других населённых пунктов.
```
# строим гистограммы
fig = px.histogram(df, # загружаем данные
                   x='total_area', # указываем столбец с данными для оси X
                   color='locality_name_category', # обозначаем категорию для разделения цветом
                   range_x=[0, 200], # ограничиваем ось X
                   title='Распределение общей площади квартиры в зависимости от расположения', # указываем заголовок
                   nbins=1000, # назначаем число корзин
                   barmode='overlay') # выбираем «полупрозрачный» тип отображения столбцов
fig.update_xaxes(title_text='Значение') # подпись для оси X
fig.update_yaxes(title_text='Частота') # подпись для оси Y
fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203424768-6028fad6-a28b-439d-81ac-95f5a3c80074.png)

С помощью параметра `color` можно выбрать категорию для разделения. Вместо одной гистограммы на экране отобразится два графика разных цветов. Какой категории соответствует каждый цвет, можно узнать из легенды графика, которую `plotly` добавит автоматически.

Графики, которые строит `plotly`, интерактивные, поэтому все параметры и значения можно проверить сразу на графике, а также поменять масштаб.

### 2  Изменение медианной стоимости квартир

Чтобы отобразить динамику медианной стоимости квартир, поступим так:

- Подготовим сводную таблицу, в которой сгруппируем данные по месяцу и году, и вычислим медианную стоимость.
- Для отображения динамики лучше всего подходит линейный график, потому его и построим. По оси X укажем месяц, а по оси Y — медианную стоимость. Года выделим цветом.

Покажем, как можно иначе оформлять заголовок и подписывать оси — с помощью параметра `update_layout`.
```
# готовим сводную таблицу
df_price_time = df.loc[df['year'] != 2014].groupby(['month','year'], as_index=False)[['last_price']].median().round()
# строим линейный график
fig = px.line(df_price_time, # загружаем данные
              x='month', # указываем столбец с данными для оси X
              y='last_price', # указываем столбец с данными для оси Y
              color='year', # обозначаем категорию для разделения цветом
              markers=True) # отображаем маркеры (точки) на графике
# оформляем график
fig.update_layout(title='Медианная стоимость в зависимости от месяца публикации',
                   xaxis_title='Месяц',
                   yaxis_title='Медианная стоимость')
fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203424995-474de936-bea3-4ad8-86f4-21102c9a409c.png)

### 3  Количество объявлений в зависимости от числа комнат

В этом случае можно использовать круговую диаграмму — pie chart. Это специфический график: лучше добавить побольше информации, чтобы всё было понятно даже неподготовленному человеку.
```
# исправляем аномалию в данных
df['rooms'] = df['rooms'].replace(0, 1)
# готовим данные для графика
df_rooms = pd.DataFrame(df['rooms'].value_counts()).reset_index()
# строим диаграмму с сегментами
fig = go.Figure(data=[go.Pie(labels=df_rooms['index'], # указываем значения, которые появятся на метках сегментов
                             values=df_rooms['rooms'], # указываем данные, которые отобразятся на графике
                             pull = [0.1, 0])]) # добавляем аргумент, который выделит сегмент-лидер на графике
fig.update_layout(title='Число квартир по количеству комнат', # указываем заголовок графика
                  width=800, # указываем размеры графика
                  height=600,
                  annotations=[dict(x=1.12, # вручную настраиваем аннотацию легенды
                                    y=1.05,
                                    text='Количество комнат',
                                    showarrow=False)])
fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203425121-9a0a7297-1cb9-4fbc-90c0-8c8ed43db45b.png)

Мы использовали параметр `update_layout` не только для указания заголовка и размера графика. Также мы настроили аннотацию легенды: указали начальные координаты отображения аннотации, добавили текст и убрали специальную стрелку.

С помощью параметра `pull` выделили на графике сегмент-лидер. Числа, которые передают параметру, обозначают, на сколько нужно «оттянуть» лидирующий сегмент от основного графика.

### 4  Лидеры по количеству объявлений

Теперь отобразим пять лидирующих населённых пунктов по количеству объявлений, исключив Санкт-Петербург. Подойдёт самая универсальная диаграмма — столбчатая. Для большей наглядности повернём её набок.

Сначала подготовим данные:
```
# отфильтруем данные, сгруппируем по городам и посчитаем объявления
df_loc_count = df.loc[df['locality_name_category'] == 'Другое'].groupby('locality_name')[['locality_name']].count()
# переименуем столбец
df_loc_count.columns = ['total_count']
# отсортируем и оставим пять лидеров
df_loc_count = df_loc_count.reset_index().sort_values(by='total_count', ascending=False).head(5)
display(df_loc_count)
```
|         | **locality_name** | **total_count** |
|--------:|------------------:|----------------:|
| **291** | посёлок Мурино    | 522             |
| **326** | посёлок Шушары    | 440             |
|  **3**  | Всеволожск        | 398             |
|  **32** | Пушкин            | 369             |
|  **13** | Колпино           | 338             |

Теперь можно строить график:
```
# строим столбчатую диаграмму 
fig = px.bar(df_loc_count.sort_values(by='total_count', ascending=True), # загружаем данные и заново их сортируем
             x='total_count', # указываем столбец с данными для оси X
             y='locality_name', # указываем столбец с данными для оси Y
             text='total_count' # добавляем аргумент, который отобразит текст с информацией
                                # о количестве объявлений внутри столбца графика
            )
# оформляем график
fig.update_layout(title='ТОП-5 населённых пунктов по количеству квартир',
                   xaxis_title='Количество объявлений',
                   yaxis_title='Населённый пункт')
fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203425406-43fe66b3-1487-4f95-9a45-6a4272020bd5.png)

Обратите внимание: параметру `text` передали количество объявлений `total_count`. Оно отобразилось на графике вместе со столбцами. 

Датафрейм df_loc_count хранит топ-5 населённых пунктов, отсортированных по убыванию количества квартир. Однако `px.bar()` по умолчанию отрисовывает столбцы диаграммы в том же порядке, что и строки в датафрейме, но размещает их снизу вверх. Таким образом, если передать методу датафрейм `df_loc_count`, отсортированный по убыванию, то на графике увидим сортировку по возрастанию:
```
# строим столбчатую диаграмму 
fig = px.bar(df_loc_count, # загружаем данные и заново их сортируем
             x='total_count', # указываем столбец с данными для оси X
             y='locality_name', # указываем столбец с данными для оси Y
             text='total_count' # добавляем аргумент, который отобразит текст с информацией
                                # о количестве объявлений внутри столбца графика
            )
# оформляем график
fig.update_layout(title='ТОП-5 населённых пунктов по количеству квартир',
                   xaxis_title='Количество объявлений',
                   yaxis_title='Населённый пункт')
fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203425543-f13b1123-7472-4698-83e3-56733ab733fd.png)

Чтобы этого избежать, методу `px.bar()` можно передать датафрейм `df_loc_count`, отсортированный по возрастанию (`df_loc_count.sort_values(by='total_count', ascending=True)`). Это один из способов «развернуть» такую сортировку.

### 5  Связь между ценой и площадью квартиры

Последнее задание — покажем, как меняется цена за квадратный метр в зависимости от общей площади квартиры в Санкт-Петербурге и вне его.

Отвечать на такие вопросы помогает график scatter. Посчитаем цену квадратного метра для каждого объявления и построим графики разных цветов в зависимости от расположения квартиры.
```
# в столбце price_m_2 сохраним отношение last_price к areа и приведём к типу int
df['price_m_2'] = (df['last_price'] / df['total_area']).astype('int')
# строим scatter
fig = px.scatter(df,             # загружаем данные
                 x='total_area', # указываем столбец с данными для оси X
                 y="price_m_2",  # указываем столбец с данными для оси Y
                 color='locality_name_category') # обозначаем категорию для разделения цветом
# оформляем график
fig.update_layout(title='Зависимость цены за квадратный метр от общей площади помещения',
                   xaxis_title='Общая площадь',
                   yaxis_title='Цена за квадратный метр')

fig.show() # выводим график
```
![изображение](https://user-images.githubusercontent.com/104757775/203425717-95158182-76c2-44ba-9194-2015eaf97855.png)

# Выводы

В библиотеке `plotly` множество инструментов и параметров. Как в случае с `matplotlib` и `seaborn`, их сложно описать в одной теме. Поэтому не забывайте пользоваться документацией: в ней вы сможете найти необходимый компонент или метод.

Последний совет: не злоупотребляйте интерактивностью. Лишние элементы могут сбить с толку неподготовленного пользователя вашей презентации. Ищите золотую середину, чтобы дополнительные элементы помогали отвечать на вопросы, а не мешали этому.
